This is a Template project used as the starting point for web design/development agency projects for clients.

All C# in this project is using C# Language 8.0.

TailwindCss is v4.1 or higher and we only use the modern CSS Config.

All .NET solutions should work with .NET Framework 4.8.1 and .NET Standard 2.0.

This is a large project that exists inside a DNN Platform (Framework) website, and
we do not modify DNN's core functionality or libraries.

This project allows us to Primarily do the following within one Git/GitHub project:
- create and manage a custom Tailwind-based theme; skins, containers, menus, etc
- create and customize 2sxc module Apps, specifically writing the Views and other file-based customizable components

Secondarily we can also
- create and manage help and tools for the client and their end-users
- create, customize, and manage tools for the users of these projects
- customize DNN's web.config keeping a record of changes
- customize robots.txt, sitemap, and related items
- customize URL rewrite and redirect mappings at the IIS level

---

## Workspace Layout & Big Picture

- Root solution: `dnn9.sln` with `dnn9.csproj`
  - This is **not** a standalone web app. It is an IntelliSense / tooling project that sits **inside** a running DNN instance.
  - All environment- and instance-specific values are imported from `dnn9.props`. Do **not** hard-code environment-specific paths into code.

- Theme & DNN assets:
  - DNN theme (skins/containers/menus) live under:
    - `dnn/Portals/_default/Skins/AccuTheme-Tw4/`
    - `dnn/Portals/_default/Skins/AccuTheme-Tw4/menus/...`
    - `dnn/Portals/_default/Containers/AccuTheme-Tw4/` (if present)
  - 2sxc views live under:
    - `dnn/Portals/0/2sxc/...` (content and app-specific Razor views)

- Tailwind / front-end build:
  - Tailwind v4.1 is configured using the **modern CSS config**.
  - Core Tailwind entry / theme files live in `src/tailwind/`:
    - `src/tailwind/index.css` (entry)
    - `src/tailwind/theme.css` – uses `@theme { ... }` for design tokens. Do **not** replace this with `@layer`.
  - The compiled CSS that DNN/skins actually use is generated by the build pipeline (via `npm` scripts; see `package.json`).
  - The compiled CSS output is written to the single file consumed (via `<link ...>`) by AccuTheme-Tw4:
    - `dnn/Portals/_default/Skins/AccuTheme-Tw4/Skin.css`

---

## Language, Framework & Tooling Constraints

- C#:
  - Use **C# 8.0** language features only (no newer pattern features, records, init-only, etc.).
  - Target frameworks are **.NET Framework 4.8.1** and **.NET Standard 2.0**; avoid APIs that require newer frameworks.

- Razor:
  - There are two main Razor environments:
    - **DNN / DDRMenu templates** (e.g., `PrimaryMenu.cshtml`) using `@inherits DotNetNuke.Web.Razor.DotNetNukeWebPage<dynamic>`.
    - **2sxc apps** using `@inherits Custom.Hybrid.RazorTyped` or `AppCode.Razor.AppRazor`.
  - Razor views are compiled by DNN/2sxc, not by ASP.NET Core. Do not introduce ASP.NET Core-specific APIs.
  - DNN uses the Roslyn 4.1 compiler (installed and configured by default as part of the DNN Platform)

- IDE / SDK:
  - `dnn9.csproj` is intentionally minimal. Its main purpose is IntelliSense and NuGet references; respect comments like “DO NOT EDIT THIS FILE”.
  - `global.json` this is considered experimental, it was introduced to fix problems with IntelliSense and is not confirmed to be doing anything useful in or for the project. It pins the .NET SDK for tooling; if something comes up where this needs to changed or experimented with, an issue should be raised and discussed.

---

## Navigation & DDR Menu Patterns

- DDR Menu inputs:
  - Most navigation templates receive a `Model` with a DDR menu tree (`Model.Source` or similar).
  - The `MenuNode` is (DNN Platform) DDR Menu's standard class object model used in Razor menus that encapsulates:
    - `TabId`, `Text`, `Url`, `Target`, `Enabled`, `Breadcrumb`, `Depth`, `Children`, etc.

- Rendering strategy:
  - Menus are built recursively:
    - A top-level method like `RenderNav(IEnumerable<MenuNode> pages, ...)` walks the tree and chooses between:
      - **MenuItem** (leaf link) and
      - **MenuDropdown** (item with children, often mapped to `<details>/<summary>`).
  - The markup is usually defined as **string templates** in `@functions` (e.g., `MenuDropdown`, `MenuItem`, `MenuStateIcon`, `MenuWrapper`), then filled via `String.Format` or `StringBuilder.AppendFormat`.

- Accessibility & state:
  - Use `<details>/<summary>` for pure CSS dropdowns where possible.
  - Mark current and breadcrumb items via `aria-current`:
    - `aria-current="page"` for the exact current page.
    - `aria-current="location"` for breadcrumb ancestors.
  - Disabled items are rendered as `<a role="link" aria-disabled="true" ...>` with `pointer-events: none` / Tailwind equivalents.

- Tailwind usage in menus:
  - Tailwind classes are embedded directly in Razor string templates.
  - When adding **dynamic** classes (depth-based, state-based), ensure the literal forms appear somewhere in the source (e.g., in comments or “force classes” sections) so Tailwind v4’s content scanner picks them up.

---

## 2sxc Views & Hybrid Razor

- 2sxc views (e.g., `dnn/Portals/0/2sxc/Content/*.cshtml`) follow patterns like:
  - `@inherits Custom.Hybrid.RazorTyped`
  - `@using AppCode.Data`
  - Optional debug helpers: `Accu.Dev.Debug`, `Accu.Dev.Log(...)` come from the namespace `Accuraty.Libraries.AccuLadder`.

- Data access:
  - Use 2sxc APIs like `App.Data.GetStream(...)`, `GetAll<T>()`, and typed POCOs in `AppCode.Data`.
  - Treat 2sxc strongly-typed APIs as the primary way to access content; avoid direct SQL or DNN APIs inside these views.
  - Direct SQL is possible but is set up (manually) in 2sxc Admin UIs as Queries using SQL DataSources

- Debugging:
  - Many views use an `if (Kit.Edit.Enabled)` block to conditionally show debug detail to editors and higher.
  - Preserve this pattern and keep debug output inside these blocks.

---

## 2sxc Views & Component Patterns

- We are currently working towards modern component pattern in our Razor-based 2sxc Views. Though there are not yet good
examples in the project/apps yet, we want to encourage a re-use pattern that allows the View to re-use component-based
razor partials.
- We would like the pattern to follow modern (2025+) component patterns in React, JSX, and related front-end frameworks.
- Nesting should be encouraged. For example, a Card component could use Heading, Image, and Text components.
- We hope to establish early a clear differentiation (grouping) between simple and complex (nested or large) components.
- The View establishes the namespaces (imports) and data for the View's components.
- The data gets mapped as props (Properties) that the Component needs/expects.
- All Components will have defaults for all Props so that they can be used without being passed props and still display a valid placeholder output.
- Initially these Compenents are entirely server-side.
- The Components will never be upgraded, they are added to (or already exist in) the project as need and then customized. This is similar to the popular Shadcn UI Components by Vercel.
- Components may have an initial default layout and structure, but any styling comes from a) the theme, b) styling passed in via props, c) manual customization (after being added to the project), etc.

---

## Tailwind v4.1 Conventions

- Do **not** use legacy `tailwind.config.js` for new configuration; use the CSS-based config (`@theme`) as seen in `src/tailwind/theme.css`.
  - Example pattern:
    ```css
    @theme {
      /* extend Tailwind's design tokens via CSS custom properties */
      /* Tailwind’s own defaults are upstream; we extend, not replace, by default. */
    }
    ```
- The Tailwind compiler ingores dynamically code-constructed Tailwind classes, however we do use them. Our two main solutions are:
  1. write code that only uses complete Tailwind classes, for example: Lets assume we need a max of 5 levels of .Depth...
    ```csharp
    foreach (var page in pages)
    {
      string mlPageDepth = page.Depth switch
      {
        1 => "ml-1",
        2 => "ml-2",
        3 => "ml-3",
        4 => "ml-4",
        5 => "ml-5",
        _ => "" // Default case, handle depths outside 1-5 if needed
      };
    ```
  2. list all possible or needed Tailwind Classes in a comments, example:
    ```csharp
    foreach (var page in pages)
    {
      // class="ml-1 ml-2 ml-3 ml-4 ml-5"
      string mlPageDepth = $"ml-{page.Depth}";
      ...
    ```

- Use utilities directly in markup:
  - No `@apply` in Razor views unless explicitly requested.
  - Prefer flex-based layouts for content and repeating elements unless there is a clear reason to use CSS Grid; explain the reason if you introduce Grid.
  - Prefer grid-based layouts for overall theme layout and structure, logical exceptions should be presented for consideration.

- Disclosure-based navigation:
  - Dropdowns and nested explorers are implemented using `<details>` / `<summary>` plus Tailwind utilities and arbitrary selectors like:
    - `summary::marker` hiding, custom chevrons with `summary::after`, `details[open]` for state, etc.

---

## Patterns & Gotchas for C# in Razor

- Scope:
  - Variables declared inside `@{ ... }` are **local to the render method** and not visible inside `@functions { ... }`.
  - To share state between page code and helper methods:
    - Declare fields/properties inside `@functions`, then set them in `@{ }`.
    - Example: `@functions { private string Disclosure; }` then `@{ Disclosure = "..."; }`.

- Arrays and safe indexing:
  - When using arrays like `MenuStateIcon` indexed by `page.Depth`, always clamp:
    ```csharp
    var icons = MenuStateIcon;
    if (icons == null || icons.Length == 0) return string.Empty;
    int idx = Math.Min(Math.Max(0, depth), icons.Length - 1);
    var iconTemplate = icons[idx];
    ```

- LINQ and null-safe access:
  - Use null-conditional and `FirstOrDefault()` safely:
    ```csharp
    int depth = pages?.FirstOrDefault()?.Depth ?? 0;
    ```

---

## Build / Packaging Workflows (High Level)

- Tailwind / front-end:
  - Use `npm` scripts (see `package.json`) to:
    - Run Tailwind in watch mode during development (`npm start` or similar); not minified.
    - Build production CSS for deployment (often `npm run build` or tailored script names); is minified.
  - Do not manually edit output CSS; edit `src/tailwind/*` and Razor markup instead.

- DNN theme packaging:
  - There is an `npm` script (e.g., `npm run dnnpackage`) that bundles the theme into a DNN-installable ZIP (skins, containers, manifest, assets).
  - Any new skin/container/asset that must ship with the theme should end up under `dnn/Portals/_default/...` and be included by the packaging scripts.

---

## How AI Agents Should Behave Here

- Do:
  - Respect framework and language constraints (.NET 4.8.1 and C# 8) .
  - Prefer netstandard2.0 compatible options over older .NET Framework options.
  - Keep DNN core and 2sxc core APIs untouched; work within theme and app boundaries.
  - Use Tailwind v4.1 modern CSS config patterns (`@theme`, utility classes in markup).
  - Preserve and use existing debug patterns (`Accu.Dev`, `Kit.Edit.Enabled` blocks).

- Avoid:
  - Introducing ASP.NET Core-only patterns (e.g., `Microsoft.AspNetCore.*` namespaces, middleware, etc.).
  - Adding new NuGet dependencies casually; align with the existing project style and constraints.
  - Changing `dnn9.csproj` structure beyond adding/removing warnings or references if absolutely needed; it is used primarily as an IntelliSense helper ad guide.

If anything in these instructions is unclear or seems to conflict with a specific file, prefer the existing file behavior and adjust these notes accordingly.

When possible or appropriate, ask questions.
